<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Personalizador 3D - Melhorias</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background-color: #f0f0f0; }
        
        #controls {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px; border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 220px; z-index: 10;
        }
        
        #position-controls {
            position: absolute; top: 20px; right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px; border-radius: 8px;
            font-size: 12px; width: 200px;
        }

        input[type="text"] { width: 100%; padding: 8px; margin-top: 5px; box-sizing: border-box; }
        .slider-group { margin-bottom: 10px; }
        label { display: block; font-weight: bold; margin-bottom: 2px; }
        input[type="range"] { width: 100%; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 20px; font-weight: bold; background: white; padding: 20px; border-radius: 10px;
        }
    </style>
</head>
<body>

    <div id="controls">
        <h3>1. Personalize</h3>
        <label>Seu Nome:</label>
        <input type="text" id="nameInput" placeholder="Digite..." value="SEU NOME" maxlength="15">
    </div>

    <div id="position-controls">
        <h3>2. Ajuste a Posição</h3>
        <p style="color: #666; margin-bottom: 10px;">Defina a posição padrão aqui.</p>
        
        <div class="slider-group">
            <label>Esquerda / Direita (X)</label>
            <input type="range" id="posX" min="-50" max="50" step="0.1" value="-35">
        </div>
        <div class="slider-group">
            <label>Cima / Baixo (Y)</label>
            <input type="range" id="posY" min="-50" max="50" step="0.1" value="-2">
        </div>
        <div class="slider-group">
            <label>Frente / Trás (Z)</label>
            <input type="range" id="posZ" min="-50" max="50" step="0.1" value="-0.3">
        </div>
        <div class="slider-group">
            <label>Tamanho do Texto</label>
            <input type="range" id="fontSize" min="0.5" max="10" step="0.1" value="3">
        </div>
        <div class="slider-group">
            <label>Rotação</label>
            <input type="range" id="rotY" min="-3.2" max="3.2" step="0.1" value="0">
        </div>
    </div>

    <div id="loading">Carregando Modelo...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // 1. CENA
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const productGroup = new THREE.Group();
        scene.add(productGroup);

        let loadedFont = null;
        let textMesh = null;

        // 2. CARREGAR MODELO
        const gltfLoader = new GLTFLoader();
        
        gltfLoader.load('modelo.glb', (gltf) => {
            const model = gltf.scene;
            const supportMaterial = new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.5 });

            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = supportMaterial;
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Zoom automático
            const box = new THREE.Box3().setFromObject(model);
            const sizeVector = new THREE.Vector3();
            box.getSize(sizeVector);
            const length = sizeVector.length();
            const center = box.getCenter(new THREE.Vector3());

            model.position.x += (model.position.x - center.x);
            model.position.y += (model.position.y - center.y);
            model.position.z += (model.position.z - center.z);

            productGroup.add(model);

            // Ajuste do Zoom Inicial (1.0x)
            camera.position.set(0, length * 0.5, length * 1.0);
            camera.lookAt(0, 0, 0);
            
            controls.target.set(0, 0, 0);
            controls.update();

            checkLoad();
        }, undefined, (error) => { console.error(error); });

        // 3. TEXTO
        const fontLoader = new FontLoader();
        fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
            loadedFont = font;
            checkLoad();
            refreshText();
        });

        function checkLoad() {
            if(productGroup.children.length > 0 && loadedFont) {
                document.getElementById('loading').style.display = 'none';
            }
        }

        function refreshText() {
            if (!loadedFont) return;
            if (textMesh) {
                scene.remove(textMesh);
                textMesh.geometry.dispose();
            }

            const text = document.getElementById('nameInput').value || " ";
            const size = parseFloat(document.getElementById('fontSize').value);

            const geometry = new TextGeometry(text, {
                font: loadedFont, size: size, height: 0.4, curveSegments: 12, bevelEnabled: false
            });
            geometry.center();

            const textMaterial = new THREE.MeshStandardMaterial({ color: 0xcc5500, roughness: 0.6 });
            textMesh = new THREE.Mesh(geometry, textMaterial);
            
            // Pega os valores atualizados dos sliders
            const x = parseFloat(document.getElementById('posX').value);
            const y = parseFloat(document.getElementById('posY').value);
            const z = parseFloat(document.getElementById('posZ').value);
            const ry = parseFloat(document.getElementById('rotY').value);

            textMesh.position.set(x, y, z);
            textMesh.rotation.y = ry;
            textMesh.castShadow = true;
            
            scene.add(textMesh);
        }

        document.getElementById('nameInput').addEventListener('input', refreshText);
        ['posX', 'posY', 'posZ', 'fontSize', 'rotY'].forEach(id => {
            document.getElementById(id).addEventListener('input', refreshText);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>